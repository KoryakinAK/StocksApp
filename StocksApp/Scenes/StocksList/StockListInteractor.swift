//
//  StockListInteractor.swift
//  StocksApp
//
//  Created by Alexey Koryakin on 20.03.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol StockListBusinessLogic {
    func sendToDetailsVC(stock: Stock)
    func loadBundleStockData()
    func downloadStockDataFor(ticker: String)
    func setFavouriteStatusFor(ticker: String, to value: Bool)
    func getCurrentFavouriteStatusFor(ticker: String) -> Bool
}

protocol StockListDataStore {
    var dataSource: [Stock] { get set }
    var dataSourceFavourites: [Stock] { get }
    var filteredDataSource: [Stock] { get set }
}

class StockListInteractor: StockListBusinessLogic, StockListDataStore {
    var presenter: StockListPresentationLogic?
    var worker: StockListWorker?
    var dataSource = [Stock]()
    var filteredDataSource = [Stock]()
    var dataSourceFavourites: [Stock] {
        return dataSource.filter { stock in
            self.getCurrentFavouriteStatusFor(ticker: stock.ticker)
        }
    }

    func sendToDetailsVC(stock: Stock) {
        presenter?.presentToDetailsVC(stock: stock)
    }

    // MARK: - Favourites interaction
    func getCurrentFavouriteStatusFor(ticker: String) -> Bool {
        return UserDefaultsManager.sharedInstance().checkIfFavouritesContain(ticker: ticker)
    }

    func setFavouriteStatusFor(ticker: String, to value: Bool) {
        if value {
            UserDefaultsManager.sharedInstance().addToFavourites(ticker: ticker)
        } else {
            UserDefaultsManager.sharedInstance().removeFromFavourites(ticker: ticker)
        }
    }

    // MARK: - Stock data interaction
    func loadBundleStockData() {
        let companyProfilesArray = Bundle.main.decode([CompanyProfile].self, from: "CompanyProfileOfflineData.json")
        let quoteArray = Bundle.main.decode([Quote].self, from: "QuoteOfflineData.json")
        let basicFinancialsArray = Bundle.main.decode([BasicFinancialsContainer].self, from: "BasicFinancialsOfflineData.json")
        for index in 0..<min(companyProfilesArray.count, quoteArray.count) {
            let stock = Stock(quote: quoteArray[index],
                              companyProfile: companyProfilesArray[index],
                              metrics: basicFinancialsArray[index].metric)
            self.presenter?.presentLoadedStocksData(response: stock)
        }
    }

    func downloadStockDataFor(ticker: String) {
        var didFailToLoad: Bool = false

        DispatchQueue.global(qos: .userInitiated).async {
            var companyResult: CompanyProfile!
            var quoteResult: Quote!
            var basicFinancialsResult: BasicFinancialsContainer!

            let APICallsDispatchGroup = DispatchGroup()
            APICallsDispatchGroup.enter()
            StockAPIWorker.requestQuote(endpoint: StocksAPI.getCompanyProfile(ticker: ticker)) { (result: Result<CompanyProfile, Error>)  in
                switch result {
                case .success(let response):
                    companyResult = response
                    APICallsDispatchGroup.leave()
                case .failure(let error):
                    didFailToLoad = true
                    APICallsDispatchGroup.leave()
                }
            }
            APICallsDispatchGroup.enter()
            StockAPIWorker.requestQuote(endpoint: StocksAPI.getQuote(ticker: ticker)) { (result: Result<Quote, Error>)  in
                switch result {
                case .success(let response):
                    quoteResult = response
                    APICallsDispatchGroup.leave()
                case .failure(let error):
                    didFailToLoad = true
                    APICallsDispatchGroup.leave()
                }
            }

            APICallsDispatchGroup.enter()
            StockAPIWorker.requestQuote(endpoint: StocksAPI.getBasicFinancials(ticker: ticker)) { (result: Result<BasicFinancialsContainer, Error>)  in
                switch result {
                case .success(let response):
                    basicFinancialsResult = response
                    APICallsDispatchGroup.leave()
                case .failure(let error):
                    didFailToLoad = true
                    APICallsDispatchGroup.leave()
                }
            }

            APICallsDispatchGroup.wait()
            DispatchQueue.main.async {
                if didFailToLoad {
                    self.presenter?.presentLoadingFailAlert()
                } else {
                    self.presenter?.presentLoadedStocksData(response: Stock(quote: quoteResult, companyProfile: companyResult, metrics: basicFinancialsResult.metric))
                }
            }
        }
    }
}
