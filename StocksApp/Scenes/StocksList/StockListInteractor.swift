//
//  StockListInteractor.swift
//  StocksApp
//
//  Created by Alexey Koryakin on 20.03.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol StockListBusinessLogic {
    func loadBundleStockData()
    func downloadStockDataFor(ticker: String)
    func setFavouriteStatusFor(ticker: String, to value: Bool)
    func getCurrentFavouriteStatusFor(ticker: String) -> Bool
}

protocol StockListDataStore {
    // var name: String { get set }
}

class StockListInteractor: StockListBusinessLogic, StockListDataStore {
    var presenter: StockListPresentationLogic?
    var worker: StockListWorker?

    func getCurrentFavouriteStatusFor(ticker: String) -> Bool {
        return UserDefaultsManager.sharedInstance().checkIfFavouritesContain(ticker: ticker)
    }

    func setFavouriteStatusFor(ticker: String, to value: Bool) {
        if value {
            UserDefaultsManager.sharedInstance().addToFavourites(ticker: ticker)
        } else {
            UserDefaultsManager.sharedInstance().removeFromFavourites(ticker: ticker)
        }
    }

    func loadBundleStockData() {
        let companyProfilesArray = Bundle.main.decode([CompanyProfile].self, from: "CompanyProfileOfflineData.json")
        let quoteArray = Bundle.main.decode([Quote].self, from: "QuoteOfflineData.json")
        for index in 0..<min(companyProfilesArray.count, quoteArray.count) {
            let stock = Stock(quote: quoteArray[index], companyProfile: companyProfilesArray[index])
            self.presenter?.presentLoadedStocksData(response: stock)
        }
    }

    func downloadStockDataFor(ticker: String) {
        var didFailToLoad: Bool = false

        DispatchQueue.global(qos: .userInitiated).async {
            var companyResult: CompanyProfile!
            var quoteResult: Quote!
            let APICallsDispatchGroup = DispatchGroup()
            APICallsDispatchGroup.enter()
            StockAPIWorker.requestQuote(endpoint: StocksAPI.getCompanyProfile(ticker: ticker)) { (result: Result<CompanyProfile, Error>)  in
                switch result {
                case .success(let response):
                    companyResult = response
                    APICallsDispatchGroup.leave()
                case .failure(let error):
                    didFailToLoad = true
                    APICallsDispatchGroup.leave()
                    // TODO: Уведомить пользователя об ошибке получения данных
                    break
                }
            }
            APICallsDispatchGroup.enter()
            StockAPIWorker.requestQuote(endpoint: StocksAPI.getQuote(ticker: ticker)) { (result: Result<Quote, Error>)  in
                switch result {
                case .success(let response):
                    quoteResult = response
                    APICallsDispatchGroup.leave()
                case .failure(let error):
                    didFailToLoad = true
                    APICallsDispatchGroup.leave()
                    break
                }
            }
            APICallsDispatchGroup.wait()
            DispatchQueue.main.async {
                if didFailToLoad {
                    self.presenter?.presentLoadingFailAlert()
                } else {
                    self.presenter?.presentLoadedStocksData(response: Stock(quote: quoteResult, companyProfile: companyResult))
                }
            }
        }
    }
}
